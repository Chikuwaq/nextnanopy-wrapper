"""
Created on 2022/05/21

The SweepHelper class facilitates postprocessing of nextnano simulations 
when single or multiple input variables are swept.

This object-oriented user interface internally & automatically invokes nnShortcuts.

@author: takuma.sato@nextnano.com
"""

# Python includes
import os
import numpy as np
import matplotlib.pyplot as plt
import itertools
import pandas as pd
import warnings
import logging
import copy
import shutil
import subprocess
import time


# nextnanopy includes
import nextnanopy as nn

# my includes
from nnShortcuts.common import CommonShortcuts
from slurmData import SlurmData



class SweepHelper:
    """
        This class bridges the input and output of the nextnanopy.Sweep() simulations to facilitate postprocessing of multiple simulation data obtained by sweeping variable(s) in the input file.

        The initialization of the class will detect the software to use and construct a table of sweep information which is useful for postprocessing.

        Running sweep simulation may take long time. If the output data already exists for the identical input file and sweep values, this class allows postprocessing without running simulations.
        WARNING: Plots do not always guarantee that the data is up-to-date, e.g. when you modify the input file but do not change the file name and sweep range.

        Notes
        -----
            - You can sweep as many variables as you like in one go.

        Attributes
        ----------
        sweep_space : dict of numpy.ndarray - { 'sweep variable': array of values }
            axes and coordinates of the sweep parameter space

        shortcuts : shortcut object
            shortcut object for the nextnano solver used for the master_input_file (automatically detected)

        master_input_file : dict of nextnanopy.InputFile object
            master input file in which one or more variables are swept.
            'original'  = original file name
            'short' = abbreviated file name

        isFilenameAbbreviated : bool
            indicates if the input file and output folder names are abbreviated

        output_folder_path : dict of str
            parent output folder path of sweep simulations
            'original'  = original file name
            'short' = abbreviated file name

        sweep_obj : nextnanopy.Sweep object
            instantiated based on self.sweep_space and self.master_input_file

        input_file_fullpaths : dict of list of str
            list of fullpath of temporary input files for the sweep.
            Paths are ordered in the same manner as self.sweep_obj.input_files.
            'original'  = original file name
            'short' = abbreviated file name
            NOTE: We split the temporary input file paths from self.sweep_obj to avoid unnecessary save_sweep(), which costs time.

        data : pandas.DataFrame object
            table of sweep data with the following columns:
                sweep_coords : tuple
                    sweep space coordinates of each simulation. (value of 1st sweep variable, value of 2nd sweep variable, ...)
                output_subfolder : str
                    output subfolder path of each simulation
                overlap : complex
                    envelope overlap between the highest hole-like and lowest electron-like states
                transition_energy : real
                    energy difference between the highest hole-like and lowest electron-like states
                hole_energy_difference : real
                    energy difference between the highest heavy-hole and highest light-hole states
            Rows are ordered in the same manner as self.sweep_obj.input_files.

        states_to_be_plotted : dict of numpy.ndarray - { 'quantum model': array of values }
            for each quantum model, array of eigenstate indices to be plotted in the figure (default: all states in the output data)

        slurm_data : SlurmData object
            information used for Slurm jobs


        Methods
        -------
        execute_sweep(self, convergenceCheck=True, show_log=False)
            Run nextnano simulations.

        delete_input_files(self)
            Delete the input files generated by the current sweep session.

        plot_dispersions(self, sweep_variable)
            Plot multiple dispersions from sweep output.

        generate_gif(self, sweep_variable)
            Generate GIF animation from multiple dispersions obtained from sweep.

        plot_overlap_squared(self, x_axis, y_axis, x_label='', y_label='', plot_title='', figFilename=None)
            Plot the overlap colormap as a function of two selected sweep axes.

        plot_transition_energies(self, x_axis, y_axis, x_label='', y_label='', plot_title='', figFilename=None)
            Plot the transition energies as a function of two selected sweep axes.

        plot_inplaneK()
            Plot the in-plane k points at which the Schroedinger equation has been solved.

        create_sbatch_scripts()
            Generate sbatch files to submit the sweep simulations to cloud computers by SLURM.

    """

    def __init__(self, sweep_ranges, master_input_file, eigenstate_range=None, round_decimal=8, loglevel=logging.INFO):
        """
        Parameters
        ----------
        sweep_ranges : dict of tuple - { 'sweep variable': tuple([min, max], number of points) }
                       OR
                       dict of list  - { 'sweep variable': list(value1, value2, ...) }
            specifies the values of each sweep variable key.

        master_input_file : nextnanopy.InputFile object
            master input file in which one or more variables are swept

        eigenstate_range : dict of list - { 'quantum model': [min, max] }, optional
            for each quantum model, eigenstates in this range will be plotted. (default: plot all states in the output data)

        round_decimal : int, optional
            maximum number of decimals for swept variables. Default is 8 (consistent to nextnanopy)

        loglevel : logging level, optional
            determines to which extent internal process should be printed to console. 
            Available options are DEBUG/INFO/WARNING/ERROR/CRITICAL. See logging module for details.

        """
        # validate arguments
        if not isinstance(sweep_ranges, dict): raise TypeError(f"__init__(): argument 'sweep_ranges' must be a dict, but is {type(sweep_ranges)}")
        # if not isinstance(master_input_file, nn.InputFile): raise TypeError(f"__init__(): argument 'master_input_file' must be a nextnanopy.InputFile object, but is {type(master_input_file)}")   # TODO: object type has been modified in nextnanopy
        
        # log setting
        fmt = '[%(levelname)s] %(message)s'
        logging.basicConfig(level=loglevel, format=fmt)
        logging.captureWarnings(True)

        # customize warning format
        def warning_on_one_line(message, category, filename, lineno, file=None, line=None):
            # return '%s:%s:\n%s: %s' % (filename, lineno, category.__name__, message)  # TODO: how to color the warning? Maybe useful https://github.com/Delgan/loguru
            return f"{category.__name__}: {message} ({filename}:{lineno})"
            # return "%(filename)s:%(lineno)d:\n %(category.__name__)s: %(message)s"
        warnings.formatwarning = warning_on_one_line

        # generate self.sweep_space
        self.sweep_space = dict()
        for var in sweep_ranges:
            if isinstance(sweep_ranges[var], tuple):  # min, max, and number of points have been given
                bounds, num_points = sweep_ranges[var]
                if bounds[0] == bounds[1] and num_points > 1:
                    raise RuntimeError(f"Sweep variable {var} has min = max, but more than one simulation is requested!")
                self.sweep_space[var] = np.around(np.linspace(bounds[0], bounds[1], num_points), round_decimal)   # avoid lengthy filenames
            elif isinstance(sweep_ranges[var], list):  # list of values has been given
                self.sweep_space[var] = np.around(np.array(sweep_ranges[var]), round_decimal)   # avoid lengthy filenames

        # prepare shortcuts for the nextnano solver used
        self.shortcuts = CommonShortcuts.get_shortcut(master_input_file)
        if self.shortcuts.product_name not in ['nextnano++', 'nextnano.NEGF', 'nextnano.NEGF++']: 
            raise NotImplementedError("class SweepHelper currently supports only nextnano++ and nextnano.NEGF++ simulations.")

        if eigenstate_range is not None:
            if not isinstance(eigenstate_range, dict): raise TypeError(f"__init__(): argument 'eigenstate_range' must be a dict, but is {type(eigenstate_range)}")
            for model, plot_range in eigenstate_range.items():
                if model not in self.shortcuts.model_names: raise KeyError(f"__init__(): Quantum model '{model}' is not supported")
                if len(plot_range) != 2: raise ValueError("__init__(): argument 'eigenstate_range' must be of the form 'quantum model': [min, max]")

        self.master_input_file = dict()
        
        # store master input file object
        self.master_input_file['original'] = copy.copy(master_input_file)
        outfolder = self.shortcuts.get_sweep_output_folder_path(self.master_input_file['original'].fullpath, *self.sweep_space.keys())
        initSweepCoords = {key: arr[0] for key, arr in self.sweep_space.items()}
        subfolder = self.shortcuts.get_sweep_output_subfolder_name(self.master_input_file['original'].fullpath, initSweepCoords)
        outpath = os.path.join(outfolder, subfolder)
        if len(outpath) + 100 > 260:
            import uuid
            logging.info(f"Because the output path is too long ({len(outpath)}), creating a temporary input file with shorter name...")
            dir = os.path.dirname(master_input_file.fullpath)
            ext = os.path.splitext(master_input_file.fullpath)[1]
            id = str(uuid.uuid4())
            filename = id[:5] + ext  # using a part of the Universally Unique Identifier
            temp_path = os.path.join(dir, filename)
            master_input_file.save(temp_path, overwrite=True, automkdir=True)
        self.master_input_file['short'] = master_input_file

        # store parent output folder path of sweep simulations
        self.output_folder_path = dict()
        self.output_folder_path['original']  = self.shortcuts.get_sweep_output_folder_path(self.master_input_file['original'].fullpath, *self.sweep_space.keys())
        self.output_folder_path['short']     = self.shortcuts.get_sweep_output_folder_path(self.master_input_file['short'].fullpath, *self.sweep_space.keys())

        self.isFilenameAbbreviated = (self.output_folder_path['short'] != self.output_folder_path['original'])

        # instantiate nn.Sweep object
        if self.isFilenameAbbreviated:
            self.sweep_obj = nn.Sweep(self.sweep_space, self.master_input_file['short'].fullpath)
        else:
            self.sweep_obj = nn.Sweep(self.sweep_space, self.master_input_file['original'].fullpath)

        self.round_decimal = round_decimal  # used by execute_sweep()
        
        self.input_file_fullpaths = dict()
        self.input_file_fullpaths['short'] = self.__create_input_file_fullpaths(self.master_input_file['short'])
        self.input_file_fullpaths['original'] = self.__create_input_file_fullpaths(self.master_input_file['original'])

        logging.debug("\nSweep space axes:")
        logging.debug(f"{ [ key for key in self.sweep_space.keys() ] }")

        # instantiate pandas.DataFrame to store sweep data
        self.data = pd.DataFrame({
            'sweep_coords' : list(itertools.product(*self.sweep_space.values())),  # create cartesian coordinates in the sweep space. Consistent to nextnanopy implementation.
            'output_subfolder' : [CommonShortcuts.get_output_subfolder_path(self.output_folder_path['original'], input_path) for input_path in self.input_file_fullpaths['original']],
            'output_subfolder_short' : [CommonShortcuts.get_output_subfolder_path(self.output_folder_path['short'], input_path) for input_path in self.input_file_fullpaths['short']],
            'overlap' : None,
            'transition_energy_eV' : None,
            'transition_energy_meV' : None,
            'transition_energy_micron' : None,
            'transition_energy_nm' : None,
            'HH1-LH1' : None,
            'HH1-HH2' : None
            })
        
        # simulation outputs of this sweep might exist already. The user might want to access those outputs without executing sweep simulation.
        if self.__output_subfolders_exist_with_originalname():
            self.isFilenameAbbreviated = False

        # for convenience in postprocessing/visualizing CSV/Excel output
        def extract_coord(tupl, index=0):
            return tupl[index]
        for i, coord in enumerate(self.sweep_space.keys()):
            self.data[coord] = self.data['sweep_coords'].apply(extract_coord, index=i)

        logging.info(f"Initialized data table:\n{self.data}")
        assert len(self.data) == len(self.input_file_fullpaths['original'])


        # initialize eigenstate indices to be plotted
        if eigenstate_range is not None:
            self.states_to_be_plotted = dict()
            for model, plot_range in eigenstate_range.items():
                self.states_to_be_plotted[model] = np.arange(plot_range[0]-1, plot_range[1], 1)
        else:   # default
            self.states_to_be_plotted = None   # if this remains None, it will be set up after sweep execution. See execute_sweep().
            # if self.__output_subfolders_exist():   # if output data exists, set to all states in the output data   # TODO: output subfolder not found when input file is NEGF...?
            #     try:
            #         datafiles_probability = self.shortcuts.get_DataFile_probabilities_in_folder(self.data.loc[0, 'output_subfolder'])
            #         self.states_to_be_plotted, num_evs = self.shortcuts.get_states_to_be_plotted(datafiles_probability)   # states_range_dict=None -> all states are plotted
            #     except FileNotFoundError as e:
            #         pass

        self.slurm_data = SlurmData()


    # def __repr__(self):
    #     return ""

    def __str__(self):
        """ this method is executed when print(SweepHelper object) is invoked """
        print("\n[SweepHelper]")
        print("\tMaster input file: ", self.master_input_file['original'].fullpath)
        print("\tSolver: ", self.shortcuts.product_name)
        print("\tSweep space grids: ")
        for var, values in self.sweep_space.items():
            print(f"\t\t{var} = ", values)
        print("\tOutput folder: ", self.__get_output_folder_path())
        print("\tOutput data exists: ", self.__output_subfolders_exist())
        return ""


    def __create_input_file_fullpaths(self, master_input_file):
        """
        Sweep.save_sweep() creates temporary input files with these names.
        However, we do not use Sweep.save_sweep() in __init__ for code speed when execution of sweep is not desired (when simulation outputs already exist).
        """
        input_file_fullpaths = []

        # code extracted from nextnanopy > inputs.py > Sweep.create_input_files()
        iteration_combinations = list(itertools.product(*self.sweep_space.values()))
        filename_path, filename_extension = os.path.splitext(master_input_file.fullpath)
        for combination in iteration_combinations:
            filename_end = '__'
            for var_name, var_value in zip(self.sweep_space.keys(), combination):
                if isinstance(var_value,str):
                    var_value_string = var_value
                else:
                    var_value_string = round(var_value, self.round_decimal)
                filename_end += '{}_{}_'.format(var_name, var_value_string)
            input_file_fullpaths.append(filename_path + filename_end + filename_extension)

        return input_file_fullpaths
    

    ### getter and checker methods of class attributes ####################################
    def __get_master_input_file(self):
        if self.isFilenameAbbreviated:
            return self.master_input_file['short']
        else:
            return self.master_input_file['original']
        

    def __get_output_folder_path(self):
        """
        Returns
        -------
        path to simulation output folder
        """
        if self.isFilenameAbbreviated:
            return self.output_folder_path['short']
        else:
            return self.output_folder_path['original']
        

    def __get_output_subfolder_paths(self):
        """
        Returns
        -------
        list of paths to simulation output subfolders
        """
        if self.isFilenameAbbreviated: 
            return self.data['output_subfolder_short']
        else:
            return self.data['output_subfolder']


    def __output_subfolders_exist(self):
        """
        Check if all output subfolders with the same input file name and sweep values exist
        (does not guarantee that the results are up-to-date!)

        Returns
        -------
        bool

        """
        return all(os.path.isdir(path) for path in self.__get_output_subfolder_paths())


    def __output_subfolders_exist_with_originalname(self):
        return all(os.path.isdir(path) for path in self.data['output_subfolder'])


    def __validate_sweep_variables(self, sweep_var):
        if sweep_var not in self.sweep_space:
            if sweep_var not in self.master_input_file['original'].variables:
                raise KeyError(f"Variable {sweep_var} is not in the input file!")
            else:
                raise KeyError(f"Variable {sweep_var} has not been swept.")
        return
    

    ### auxillary postprocessing methods ####################################
    def __slice_data_for_colormap_2D(self, key, x_axis, y_axis, datatype=np.double):
        """
        Extract the data along two specified sweep parameters

        Parameters
        ----------
        key : str
            key in self.data object, specifying the data to be sliced
        x_axis : str
            sweep variable to be taken for x-axis.
        y_axis : str
            sweep variable to be taken for y-axis.
        datatype : numpy.dtype, optional
            Data type of the sliced data will be set to this type.

        Returns
        -------
        x_values : 1D numpy array
            Values of the first sweep variable
        y_values : 1D numpy array
            Values of the second sweep variable
        res : 2D numpy array
            Sliced data

        """
        # validate arguments
        if key not in self.data.keys():
            raise ValueError(f"{key} is not calculated in this sweep!")
        self.__validate_sweep_variables(x_axis)
        self.__validate_sweep_variables(y_axis)

        x_values = self.sweep_space[x_axis]
        y_values = self.sweep_space[y_axis]

        # identify index of plot axes
        for i, var in enumerate(self.sweep_space.keys()):
            if var == x_axis:
                x_axis_variable_index = i
            if var == y_axis:
                y_axis_variable_index = i

        sweep_space_reduced = self.__extract_2D_plane_from_sweep_space(x_axis, y_axis)

        # returns bool whether the point in the sweep space belongs to the plot region
        def isIn(coords):
            return all(coords[i] in sweep_space_reduced[var] for i, var in enumerate(self.sweep_space.keys()))

        # pick up sub-array of overlap data accordingly
        # res = [[0 for i in range(len(y_values))] for i in range(len(x_values))]
        res = np.zeros((len(y_values), len(x_values)), dtype=datatype)  # matplotlib pcolormesh assumes (num of y values)=(num of rows) and (num of x values)=(num of columns) for C axis data
        for coords, quantity in zip(self.data['sweep_coords'], self.data[key]):
            if not isIn(coords): continue

            xIndex = np.where(x_values == coords[x_axis_variable_index])   # find index for which arr == value
            yIndex = np.where(y_values == coords[y_axis_variable_index])
            res[yIndex, xIndex] = quantity  # matplotlib pcolormesh assumes (num of y values)=(num of rows) and (num of x values)=(num of columns) for C axis data

        return x_values, y_values, res

    
    def __slice_data_for_colormap_1D(self, key, x_axis, datatype=np.double):
        """
        Extract the data along one specified sweep parameter

        Parameters
        ----------
        key : str
            key in self.data object, specifying the data to be sliced
        x_axis : str
            sweep variable to be taken for x-axis.
        datatype : numpy.dtype, optional
            Data type of the sliced data will be set to this type.

        Returns
        -------
        x_values : 1D numpy array
            Values of the first sweep variable
        res : 1D numpy array
            Sliced data

        """
        # validate arguments
        if key not in self.data.keys():
            raise ValueError(f"{key} is not calculated in this sweep!")
        self.__validate_sweep_variables(x_axis)
        
        x_values = self.sweep_space[x_axis]
        
        # identify index of plot axes
        for i, var in enumerate(self.sweep_space.keys()):
            if var == x_axis:
                x_axis_variable_index = i
        
        sweep_space_reduced = self.__extract_1D_line_from_sweep_space(x_axis)

        # returns bool whether the point in the sweep space belongs to the plot region
        def isIn(coords):
            return all(coords[i] in sweep_space_reduced[var] for i, var in enumerate(self.sweep_space.keys()))

        # pick up sub-array of overlap data accordingly
        res = np.zeros(len(x_values), dtype=datatype)
        for coords, quantity in zip(self.data['sweep_coords'], self.data[key]):
            if not isIn(coords): continue

            xIndex = np.where(x_values == coords[x_axis_variable_index])   # find index for which arr == value
            res[xIndex] = quantity

        return x_values, res


    def __extract_1D_line_from_sweep_space(self, sweep_var):
        """
        Extract 1D line from multidimensional (d >= 1) sweep space.
        """
        sweep_space_reduced = self.sweep_space

        # ask the values for other axes
        logging.info(f"Taking '{sweep_var}' for plot axis.")
        for var, array in self.sweep_space.items():
            if var == sweep_var: continue

            print("\nRemaining sweep dimension: ", var)
            print("Simulation has been performed at: ")
            for i, val in enumerate(array):
                print(f"index {i}: {val}")
            if len(array) == 1:
                iChoice = 0
            else:
                while True:
                    choice = input("Specify value for the plot by index: ")
                    if choice == 'q':
                        raise RuntimeError('Nextnanopy terminated.') from None
                    try:
                        iChoice = int(choice)
                    except ValueError:
                        print("Invalid input. (Type 'q' to quit)")
                        continue
                    if iChoice not in range(len(array)):
                        print("Invalid input. (Type 'q' to quit)")
                    else:
                        break
            sweep_space_reduced[var] = [array[iChoice]]   # only one element, but has to be an Iterable for the later use
        return sweep_space_reduced


    def __extract_2D_plane_from_sweep_space(self, sweep_var1, sweep_var2):
        """
        Extract 2D plane from multidimensional (d >= 2) sweep space.
        """
        sweep_space_reduced = self.sweep_space

        # ask the values for other axes
        logging.info(f"Taking '{sweep_var1}' and '{sweep_var2}' for plot axes.")
        for var, array in self.sweep_space.items():
            if var == sweep_var1 or var == sweep_var2: continue

            print("\nRemaining sweep dimension: ", var)
            print("Simulation has been performed at: ")
            for i, val in enumerate(array):
                print(f"index {i}: {val}")
            if len(array) == 1:
                iChoice = 0
            else:
                while True:
                    choice = input("Specify value for the plot by index: ")
                    if choice == 'q':
                        raise RuntimeError('Nextnanopy terminated.') from None
                    try:
                        iChoice = int(choice)
                    except ValueError:
                        print("Invalid input. (Type 'q' to quit)")
                        continue
                    if iChoice not in range(len(array)):
                        print("Invalid input. (Type 'q' to quit)")
                    else:
                        break
            sweep_space_reduced[var] = [array[iChoice]]   # only one element, but has to be an Iterable for the later use
        logging.debug("Extracted sweep_space", sweep_space_reduced)
        return sweep_space_reduced


    def __setup_2D_color_plot(self, ax, x_axis, y_axis, x_label, y_label, plot_title, x_values, y_values):
        """ 
        Set labels, ticks and titles of a 2D colormap plot 
        """
        if x_label is None: x_label = x_axis
        if y_label is None: y_label = y_axis

        ax.set_xlabel(x_label)
        ax.set_ylabel(y_label)
        ax.set_title(plot_title)
        plt.xticks(x_values)
        plt.yticks(y_values)

        # trim x- and y-axis tick labels, while keeping all the ticks present
        nSimulations_x = len(self.sweep_space[x_axis])
        nSimulations_y = len(self.sweep_space[y_axis])
        max_num_xticks = 6   # TBD
        max_num_yticks = 20  # TBD
        if nSimulations_x > max_num_xticks:
            xticklabel_interval = int(nSimulations_x / max_num_xticks)
            for i, xtick in enumerate(ax.xaxis.get_ticklabels()):  
                if i % xticklabel_interval != 0: xtick.set_visible(False)
        if nSimulations_y > max_num_yticks:
            yticklabel_interval = int(nSimulations_y / max_num_yticks)
            for i, ytick in enumerate(ax.yaxis.get_ticklabels()):
                if i % yticklabel_interval != 0: ytick.set_visible(False)

    
    def __setup_1D_plot(self, ax, x_axis, x_label, plot_title, x_values):
        """ 
        Set labels, ticks and titles of a 1D plot 
        """
        if x_label is None: x_label = x_axis
        
        ax.set_xlabel(x_label)
        ax.set_title(plot_title)
        plt.xticks(x_values)
        
        # trim x- and y-axis tick labels, while keeping all the ticks present
        nSimulations_x = len(self.sweep_space[x_axis])
        max_num_xticks = 6   # TBD
        if nSimulations_x > max_num_xticks:
            xticklabel_interval = int(nSimulations_x / max_num_xticks)
            for i, xtick in enumerate(ax.xaxis.get_ticklabels()):  
                if i % xticklabel_interval != 0: xtick.set_visible(False)
        


    ### Sweep execution #####################################################
    def execute_sweep(self, convergenceCheck=True, show_log=False, parallel_limit=1, **kwargs):
        """
        Run simulations.
        
        Use the method 'recover_original_filenames()' to recover the original input file name in the output folders after nextnano execution 
        if the input file name has been abbreviated due to limited output path length.

        Parameters
        ----------
        convergenceCheck : bool, optional
            The default is True.
        show_log : bool, optional
            The default is False.
        parallel_limit : int, optional
            Maximum number of parallel execution
        kwargs : optional
            other parameters accepted by nextnanopy.InputFile.execute()

        """
        # warn the user if many serial simulations are requested
        num_of_simulations = self.data['sweep_coords'].size
        if parallel_limit == 1:
            if (num_of_simulations > 100 and self.shortcuts.product_name == 'nextnano++') or (num_of_simulations > 10 and self.shortcuts.product_name == 'nextnano.NEGF'):
                while (True):
                    choice = input(f"WARNING: {num_of_simulations} simulations requested without parallelization. Are you sure you want to run all of them one-by-one? [y/n]")
                    if choice == 'y': break
                    elif choice == 'n': raise RuntimeError('Nextnanopy terminated.')

        logging.info("Saving sweep input files...")
        self.sweep_obj.save_sweep(delete_old_files=True, round_decimal=self.round_decimal)  # ensure the same decimals for self.sweep_space and input file names
        logging.info("Saved.")

        logging.info(f"Running {num_of_simulations} simulations with max. {parallel_limit} parallelization for \n{self.master_input_file['short'].fullpath}")

        # execute sweep simulations
        # this writes output to self.data['output_subfolder_short']
        self.sweep_obj.execute_sweep(
                delete_input_files = False,   # Do not delete input files so that SweepHelper.execute_sweep() can be invoked independently of __init__.
                overwrite          = True,    # avoid enumeration of output folders for secure output data access. 
                convergenceCheck   = convergenceCheck, 
                show_log           = show_log, 
                parallel_limit     = parallel_limit,
                **kwargs
                )   

        # point to the new output in case old simulation outputs exist with original file name
        self.isFilenameAbbreviated = (self.output_folder_path['short'] != self.output_folder_path['original'])

        # If not given at the class instantiation, determine how many eigenstates to plot (states_to_be_plotted attribute)
        if self.states_to_be_plotted is None:   # by default, plot all states in the output data
            if os.path.exists(self.data.loc[0, 'output_subfolder']):
                try: 
                    datafiles_probability = self.shortcuts.get_DataFile_probabilities_in_folder(self.data.loc[0, 'output_subfolder'])
                    self.states_to_be_plotted, num_evs = self.shortcuts.get_states_to_be_plotted(datafiles_probability)   # states_range_dict=None -> all states are plotted
                except FileNotFoundError:  # 1,2,3-band NEGF doesn't have probability output
                    warnings.warn("SweepHelper.execute_sweep(): Probability distribution not found")


    def recover_original_filenames(self):
        """
        TODO: Implement similar method for Slurm jobs, which do not rely on nextnanopy.Sweep object
        """
        if not self.isFilenameAbbreviated:
            return
        
        logging.info(f"Reverting output folder name from \n{self.output_folder_path['short']} to\n{self.output_folder_path['original']}")
        
        # move the subfolders from 'short' to 'original' root folder
        # if os.path.isdir(self.output_folder_path['original']):
        #     TODO: Fix: folders move to wrong places
        #     for subfolder in os.listdir(self.output_folder_path['short']):  # os.listdir() cannot return full paths!
        #         try:
        #             logging.info(f"Moving {subfolder} to \n{self.output_folder_path['original']}")
        #             shutil.move(os.path.join(self.output_folder_path['short'], subfolder), self.output_folder_path['original'])  # if the destination is an existing directory, move the source inside that directory
        #         except:
        #             warnings.warn(f"shutil.move() for file {subfolder} skipped.")
        # else:
        #     shutil.move(self.output_folder_path['short'], self.output_folder_path['original'])
        
        # if the output of the original folder name exists, delete because shutil.move() cannot overwrite if the destination exists
        if os.path.isdir(self.output_folder_path['original']):
            try: 
                shutil.rmtree(self.output_folder_path['original'])
            except OSError as e:
                raise
        
        # rename folder
        shutil.move(self.output_folder_path['short'], self.output_folder_path['original'])
        
        # within 'original' folder, rename subfolders
        for short, original in zip(self.input_file_fullpaths['short'], self.input_file_fullpaths['original']):
            current_output_subfolder = CommonShortcuts.get_output_subfolder_path(self.output_folder_path['original'], short)
            original_output_subfolder = CommonShortcuts.get_output_subfolder_path(self.output_folder_path['original'] , original)
            shutil.move(current_output_subfolder, original_output_subfolder)

        self.isFilenameAbbreviated = False


    def delete_input_files(self):
        """
        Delete the temporary input files of the sweep object.
        
        Notes
        -----
        Convenient to have a separate method so that self.execute_sweep() can be invoked independently of __init__().
        """
        input_file_fullpaths = self.input_file_fullpaths['original'] + self.input_file_fullpaths['short']
        paths = set(input_file_fullpaths)  # avoid duplicates
        for path in paths:
            if os.path.exists(path):
                os.remove(path)

        # delete the input file whose name has been abbreviated
        if self.isFilenameAbbreviated:
            os.remove(self.master_input_file['short'].fullpath)
        logging.info("Sweep (temporary) input files deleted.")


    def delete_output(self):
        """
        Delete the output data of the sweep object.
        """
        outfolder = self.__get_output_folder_path()
        if not os.path.exists(outfolder):
            warnings.warn("Output folder does not exist!")
            return
        try:
            shutil.rmtree(outfolder)
        except OSError as e:
            raise


    def submit_sweep_to_slurm(self, suffix='', node='microcloud', email=None, num_CPU=4, memory_limit='8G', time_limit_hrs=5, exe=None, output_folder=None, database=None):
        """
        Submit sweep simulations to Slurm workload manager.

        Parameters
        ----------
            node : str
                name of the computer node
            email : str
                Email is sent when the last input file in the sweep has finished.
            num_CPU : int
                number of CPUs available. Used for the nextnano command line parameter '--threads'
                Number of physical cores = num_CPU
                Number of threads when hyperthreading = 2 * num_CPU
                Optimal number of threads for omp parallelism <= (2 * num_CPU) / 2 = num_CPU
        """
        self.slurm_data.set(node, suffix, email, num_CPU, memory_limit, time_limit_hrs)

        # defaults
        if exe is None:           exe, = nn.config.get(self.shortcuts.product_name, 'exe'),
        if output_folder is None: output_folder = self.__get_output_folder_path()
        if database is None:      database = nn.config.get(self.shortcuts.product_name, 'database')
        license = nn.config.get(self.shortcuts.product_name, 'license')

        self.input_file_fullpaths['original'] = list(set(self.input_file_fullpaths['original']))  # BUG: for some reason, input file paths are duplicated
        self.slurm_data.create_sbatch_scripts(self.input_file_fullpaths['original'], exe, output_folder, database, license, self.shortcuts.product_name)

        logging.info("Saving sweep input files...")
        self.sweep_obj.save_sweep(delete_old_files=True, round_decimal=self.round_decimal)  # creates temp input files. Ensure the same decimals for self.sweep_space and input file names
        
        for iMetascript, metascript_path in enumerate(self.slurm_data.metascript_paths):
            logging.info(f"Submitting jobs to Slurm (metascript {iMetascript+1} / {len(self.slurm_data.metascript_paths)})...")
            subprocess.run(['bash', metascript_path])
            self.wait_slurm_jobs()

        self.slurm_data.delete_sbatch_scripts()


    def wait_slurm_jobs(self):
        """
        Wait until all jobs with the name `SlurmData.jobname` complete or fail.
        """
        time.sleep(5)
        stopwatch = 0

        def isRunning():
            # Run the sacct command and capture the output
            commands = ['sacct', '|', 'grep', SlurmData.jobname, 'grep', self.slurm_data.node]
            result = subprocess.run(commands, capture_output=True, text=True)
            return ('RUNNING' in result.stdout)
        
        while isRunning():
            time.sleep(10)
            stopwatch += 10
            logging.info(f"Slurm job(s) running... ({stopwatch} sec)")
            

    ### Import methods #######################################################
    def import_from_excel(self, excel_file_path):
        """
        Enables postprocessing without raw simulation data.
        Useful when the sweep output occupies a lot of memory and the user wishes to delete them.
        """
        try:
            self.data = pd.read_excel(excel_file_path)
        except:
            raise
        logging.info("Imported data from Excel file.")
        self.__str__()

                
    ### Export methods #######################################################
    def export_to_excel(self, excel_file_path, force_lightHole=False):
        """
        The sweep data can be exported to an Excel file by:
            SweepHelper.data.to_excel()
        For the available options, see pandas.DataFrame.
        """
        self.__calc_overlap(force_lightHole)
        self.__calc_transition_energies(force_lightHole)
        self.__calc_HH1_LH1_energy_differences()
        self.__calc_HH1_HH2_energy_differences()

        logging.info(f"Exporting data to Excel file:\n{excel_file_path}")
        from pathlib import Path
        filepath = Path(excel_file_path)
        filepath.parent.mkdir(parents=True, exist_ok=True)
        self.data.to_excel(filepath)


    def export_to_csv(self, csv_file_path, force_lightHole=False):
        """
        The sweep data can be exported to a CSV file by:
            SweepHelper.data.to_csv()
        For the available options, see pandas.DataFrame.
        """
        self.__calc_overlap(force_lightHole)
        self.__calc_transition_energies(force_lightHole)
        self.__calc_HH1_LH1_energy_differences()
        self.__calc_HH1_HH2_energy_differences()

        logging.info(f"Exporting data to CSV file:\n{csv_file_path}")
        from pathlib import Path
        filepath = Path(csv_file_path)
        filepath.parent.mkdir(parents=True, exist_ok=True)
        self.data.to_csv(filepath)


    ### Dispersion ###########################################################
    def plot_dispersions(self, sweep_variable, savePDF=False):
        """
        Plot multiple dispersions from sweep output.

        Parameters
        ----------
        sweep_variable : str
            sweep variable name

        Returns
        -------
        None.

        """
        if not self.__output_subfolders_exist():
            raise RuntimeError("Simulation output does not exist for this sweep!")

        # validate argument
        self.__validate_sweep_variables(sweep_variable)

        sweep_space_reduced = self.__extract_1D_line_from_sweep_space(sweep_variable)

        # returns bool whether the point in the sweep space belongs to the plot region
        def isIn(coords):
            return all(coords[i] in sweep_space_reduced[var] for i, var in enumerate(sweep_space_reduced.keys()))

        # plot dispersions
        for model in self.states_to_be_plotted.keys():
            for coords, outfolder in zip(self.data['sweep_coords'], self.__get_output_subfolder_paths()):
                if isIn(coords):
                    self.shortcuts.plot_dispersion(outfolder, np.amin(self.states_to_be_plotted[model]), np.amax(self.states_to_be_plotted[model]), savePDF=savePDF)
        return


    def generate_gif(self, sweep_variable):
        """
        Generate GIF animation from multiple dispersions obtained from sweep.

        Parameters
        ----------
        sweep_variable : str
            sweep variable name

        Returns
        -------
        None.

        Note
        ----
        Currently, only 1D sweep is supported!!

        """
        if not self.__output_subfolders_exist():
            raise RuntimeError("Simulation output does not exist for this sweep!")

        # validate argument
        self.__validate_sweep_variables(sweep_variable)

        # generate GIF
        self.shortcuts.generate_gif(self.master_input_file['original'], sweep_variable, self.sweep_space[sweep_variable], self.states_to_be_plotted)


    ### Optics analysis #######################################################
    def __calc_overlap(self, force_lightHole):
        """
        Compute overlaps and store them in self.data
        """
        if not self.data['overlap'].isna().any():
            return
        logging.info("Calculating overlap...")
        self.data['overlap'] = self.__get_output_subfolder_paths().apply(self.shortcuts.calculate_overlap, force_lightHole=force_lightHole)
        # self.data['overlap_squared'] = self.data['overlap'].apply(common.absolute_squared)   # BUG: somehow the results become complex128, not float --> cannot be plotted
        

    def __calc_transition_energies(self, force_lightHole):
        """
        Get transition energies and store them in self.data
        """
        if not self.data['transition_energy_eV'].isna().any():
            return
        
        if self.shortcuts.product_name == 'nextnano++':
            self.data['transition_energy_eV'] = self.__get_output_subfolder_paths().apply(self.shortcuts.get_transition_energy, force_lightHole=force_lightHole)
        elif self.shortcuts.product_name == 'nextnano.NEGF++':
            self.data['transition_energy_eV'] = self.__get_output_subfolder_paths().apply(self.shortcuts.get_transition_energy)

        # Convert units
        self.data['transition_energy_meV']    = self.data['transition_energy_eV'] * CommonShortcuts.scale1ToMilli
        self.data['transition_energy_micron'] = self.data['transition_energy_eV'].apply(CommonShortcuts.electronvolt_to_micron)
        self.data['transition_energy_nm']     = self.data['transition_energy_micron'] * 1e3
        

    def __calc_HH1_LH1_energy_differences(self):
        """
        Get the energy difference HH1 - LH1 and store them in self.data
        """
        if not self.data['HH1-LH1'].isna().any():
            return
        self.data['HH1-LH1'] = self.__get_output_subfolder_paths().apply(self.shortcuts.get_HH1_LH1_energy_difference)


    def __calc_HH1_HH2_energy_differences(self):
        """
        Get the energy difference HH1 - HH2 and store them in self.data
        """
        if not self.data['HH1-HH2'].isna().any():
            return
        self.data['HH1-HH2'] = self.__get_output_subfolder_paths().apply(self.shortcuts.get_HH1_HH2_energy_difference)


    def plot_overlap_squared(self, x_axis, y_axis, x_label=None, y_label=None, force_lightHole=False, plot_title='', figFilename=None, colormap='Greys'):
        """
        Plot the overlap colormap as a function of two selected sweep axes.

        Parameters
        ----------
        x_axis : str
            sweep variable for x-axis
        y_axis : str
            sweep variable for y-axis
        x_label : str, optional
            custom x-axis label
        y_label : str, optional
            custom y-axis label
        plot_title : str, optional
            title of the plot
        figFilename : str, optional
            output file name
        colormap : str, optional
            colormap used for the color bar

        Returns
        -------
        fig : matplotlib.figure.Figure object

        """
        if not self.__output_subfolders_exist():
            raise RuntimeError("Simulation output does not exist for this sweep!")

        # validate input
        self.__validate_sweep_variables(x_axis)
        self.__validate_sweep_variables(y_axis)      

        self.__calc_overlap(force_lightHole)

        # x- and y-axis coordinates and 2D array-like of overlap data
        x_values, y_values, overlap = self.__slice_data_for_colormap_2D('overlap', x_axis, y_axis, datatype=np.cdouble)   # complex double = two double-precision floats
        overlap_squared = np.abs(overlap)**2
        
        assert np.amin(overlap_squared) >= 0


        # instantiate 2D color plot
        fig, ax = plt.subplots()
        if not plot_title: plot_title = "Envelope overlap"
        self.__setup_2D_color_plot(ax, x_axis, y_axis, x_label, y_label, plot_title, x_values, y_values)

        # color setting
        from matplotlib import colors
        divnorm = colors.Normalize(vmin=0.)   # set the colorscale minimum to 0
        pcolor = ax.pcolormesh(x_values, y_values, overlap_squared, cmap=colormap, norm=divnorm, shading='auto')
        # pcolor = ax.pcolormesh(x_values, y_values, overlap_squared, cmap=colormap, shading='auto')

        cbar = fig.colorbar(pcolor)
        cbar.set_label("Envelope overlap")
        fig.tight_layout()
        plt.show()

        if figFilename is None or figFilename == "":
            name = os.path.split(self.output_folder_path['original'])[1]
            figFilename = name + "_overlap"
        self.shortcuts.export_figs(figFilename, "png", output_folder_path=self.__get_output_folder_path(), fig=fig)


        # write info to a file
        max_val, indices = CommonShortcuts.find_maximum(overlap_squared)  
        y_index, x_index = indices
        filepath = os.path.join(self.__get_output_folder_path(), os.path.join("nextnanopy", "info.txt"))
        logging.info(f"Writing info to:\n{filepath}")
        f = open(filepath, "w")  # w = write = overwrite existing content
        f.write(f"Overlap squared maximum {max_val} at:\n")
        f.write(f"{x_axis} = {x_values[x_index]}\n")
        f.write(f"{y_axis} = {y_values[y_index]}\n")
        f.close()
        
        return fig


    def plot_transition_energies(self, x_axis, y_axis=None, x_label=None, y_label=None, force_lightHole=False, plot_title='', figFilename=None, colormap=None, set_center_to_zero=False, unit='meV', export_data=False):
        """
        Plot the transition energy (lowest electron eigenenergy - highest hole eigenenergy) colormap as a function of two selected sweep axes.

        Parameters
        ----------
        x_axis : str
            sweep variable for x-axis
        y_axis : str, optional
            sweep variable for y-axis
        x_label : str, optional
            custom x-axis label
        y_label : str, optional
            custom y-axis label
        plot_title : str, optional
            title of the plot
        figFilename : str, optional
            output file name
        colormap : str, optional
            colormap used for the color bar
        set_center_to_zero : bool, optional
            If you are interested in the sign of transition energy (e.g. insulator-semimetal-topological insulator phase transition), set to True.
            Default is False
        unit : str, optional
            unit of transition energy. Currently supports 'meV' 'micron' 'um' 'nm'
        export_data : bool, optional
            If True, return the processed data ready for manual plot.
            If False, return figure

        Returns
        -------
        If export_data,
            x_values, y_values, scaled transition energies
        else,
            matplotlib.figure.Figure object

        """
        if not self.__output_subfolders_exist():
            raise RuntimeError("Simulation output does not exist for this sweep!")

        # validate input
        self.__validate_sweep_variables(x_axis)
        if y_axis is None:
            plot_2D = False
        else:
            plot_2D = True
            self.__validate_sweep_variables(y_axis)
        if unit not in ['meV', 'micron', 'um', 'nm']:
            raise ValueError(f"Energy unit {unit} is not supported.")

        self.__calc_transition_energies(force_lightHole)

        # x- and y-axis coordinates and 2D array-like of overlap data
        if plot_2D:
            if unit == 'meV':
                x_values, y_values, transition_energies = self.__slice_data_for_colormap_2D('transition_energy_meV', x_axis, y_axis, datatype=np.double)
            elif unit == 'micron' or unit == 'um':
                x_values, y_values, transition_energies = self.__slice_data_for_colormap_2D('transition_energy_micron', x_axis, y_axis, datatype=np.double)
            elif unit == 'nm':
                x_values, y_values, transition_energies = self.__slice_data_for_colormap_2D('transition_energy_nm', x_axis, y_axis, datatype=np.double)
        else:
            if unit == 'meV':
                x_values, transition_energies = self.__slice_data_for_colormap_1D('transition_energy_meV', x_axis, datatype=np.double)
            elif unit == 'micron' or unit == 'um':
                x_values, transition_energies = self.__slice_data_for_colormap_1D('transition_energy_micron', x_axis, datatype=np.double)
            elif unit == 'nm':
                x_values, transition_energies = self.__slice_data_for_colormap_1D('transition_energy_nm', x_axis, datatype=np.double)

        
        if export_data:
            if plot_2D:
                return x_values, y_values, transition_energies
            else:
                return x_values, transition_energies
        else:
            if plot_2D:
                fig = self.__plot_transition_energies_2D(x_axis, y_axis, x_label, y_label, x_values, y_values, plot_title, colormap, set_center_to_zero, unit, transition_energies)
            else:
                fig = self.__plot_transition_energies_1D(x_axis, x_label, x_values, plot_title, unit, transition_energies)

            if figFilename is None or figFilename == "":
                name = os.path.split(self.output_folder_path['original'])[1]
                figFilename = name + "_transitionEnergies"
            self.shortcuts.export_figs(figFilename, "png", output_folder_path=self.__get_output_folder_path(), fig=fig)
            return fig

        

    def __plot_transition_energies_2D(self, x_axis, y_axis, x_label, y_label, x_values, y_values, plot_title, colormap, set_center_to_zero, unit, transition_energies_scaled):
        if transition_energies_scaled.ndim != 2:
            raise ValueError("Transition_energies_scaled must be two dimensional!")

        # instantiate 2D color plot
        fig, ax = plt.subplots()
        if not plot_title: plot_title = "Transition energies"
        self.__setup_2D_color_plot(ax, x_axis, y_axis, x_label, y_label, plot_title, x_values, y_values)

        # color setting
        if colormap is None:  
            # default colors
            if set_center_to_zero: 
                colormap = 'seismic'
            else:
                colormap = 'viridis'
        if set_center_to_zero:
            from matplotlib import colors
            divnorm = colors.TwoSlopeNorm(vcenter=0.)
            pcolor = ax.pcolormesh(x_values, y_values, transition_energies_scaled, cmap=colormap, norm=divnorm, shading='auto')
        else:
            pcolor = ax.pcolormesh(x_values, y_values, transition_energies_scaled, cmap=colormap, shading='auto')
        
        cbar = fig.colorbar(pcolor)
        if unit == 'meV':
            cbar.set_label("Transition energy ($\mathrm{meV}$)")
        elif unit == 'micron' or unit == 'um':
            cbar.set_label("Wavelength ($\mu\mathrm{m}$)")
        elif unit == 'nm':
            cbar.set_label("Wavelength ($\mathrm{nm}$)")
        fig.tight_layout()
        plt.show()

        return fig


    def __plot_transition_energies_1D(self, x_axis, x_label, x_values, plot_title, unit, transition_energies_scaled):
        if transition_energies_scaled.ndim != 1:
            raise ValueError("Transition_energies_scaled must be one dimensional!")
        
        # instantiate 1D plot
        fig, ax = plt.subplots()
        if not plot_title: plot_title = "Transition energies"
        self.__setup_1D_plot(ax, x_axis, x_label, plot_title, x_values)

        if unit == 'meV':
            ax.set_ylabel("Transition energy ($\mathrm{meV}$)")
        elif unit == 'micron' or unit == 'um':
            ax.set_ylabel("Wavelength ($\mu\mathrm{m}$)")
        elif unit == 'nm':
            ax.set_ylabel("Wavelength ($\mathrm{nm}$)")
        ax.plot(x_values, transition_energies_scaled)
        fig.tight_layout()
        plt.show()

        return fig


    ### highest hole states ###################################################
    def plot_HH1_LH1_energy_difference(self, x_axis, y_axis, x_label=None, y_label=None, plot_title='', figFilename=None, colormap=None, set_center_to_zero=True):
        """
        Plot the hole energy difference (HH - LH) colormap as a function of two selected sweep axes.

        Parameters
        ----------
        x_axis : str
            sweep variable for x-axis
        y_axis : str
            sweep variable for y-axis
        x_label : str, optional
            custom x-axis label
        y_label : str, optional
            custom y-axis label
        plot_title : str, optional
            title of the plot
        figFilename : str, optional
            output file name
        colormap : str, optional
            colormap used for the color bar
        set_center_to_zero : bool, optional
            If you are interested in the sign of transition energy (e.g. insulator-semimetal-topological insulator phase transition), set to True.
            Default is True

        Returns
        -------
        fig : matplotlib.figure.Figure object

        """
        if not self.__output_subfolders_exist():
            raise RuntimeError("Simulation output does not exist for this sweep!")

        # validate input
        self.__validate_sweep_variables(x_axis)
        self.__validate_sweep_variables(y_axis)

        self.__calc_HH1_LH1_energy_differences()

        # x- and y-axis coordinates and 2D array-like of overlap data
        x_values, y_values, transition_energies = self.__slice_data_for_colormap_2D('HH1-LH1', x_axis, y_axis, datatype=np.double)


        # instantiate 2D color plot
        fig, ax = plt.subplots()
        if not plot_title: plot_title = "Energy difference HH1 - LH1"
        self.__setup_2D_color_plot(ax, x_axis, y_axis, x_label, y_label, plot_title, x_values, y_values)

        # color setting
        if colormap is None:  
            # default colors
            if set_center_to_zero: 
                colormap = 'seismic'
            else:
                colormap = 'viridis'
        if set_center_to_zero:
            from matplotlib import colors
            divnorm = colors.TwoSlopeNorm(vcenter=0.)
            pcolor = ax.pcolormesh(x_values, y_values, transition_energies * CommonShortcuts.scale1ToMilli, cmap=colormap, norm=divnorm, shading='auto')
        else:
            pcolor = ax.pcolormesh(x_values, y_values, transition_energies * CommonShortcuts.scale1ToMilli, cmap=colormap, shading='auto')
        
        cbar = fig.colorbar(pcolor)
        cbar.set_label("Hole energy difference HH-LH ($\mathrm{meV}$)")
        fig.tight_layout()
        plt.show()

        if figFilename is None or figFilename == "":
            name = os.path.split(self.output_folder_path['original'])[1]
            figFilename = name + "_HH1_LH1_EnergyDifference"
        self.shortcuts.export_figs(figFilename, "png", output_folder_path=self.__get_output_folder_path(), fig=fig)

        return fig


    def plot_HH1_HH2_energy_difference(self, x_axis, y_axis, x_label=None, y_label=None, plot_title='', figFilename=None, colormap=None, set_center_to_zero=True):
        """
        Plot the hole energy difference (HH - LH) colormap as a function of two selected sweep axes.

        Parameters
        ----------
        x_axis : str
            sweep variable for x-axis
        y_axis : str
            sweep variable for y-axis
        x_label : str, optional
            custom x-axis label
        y_label : str, optional
            custom y-axis label
        plot_title : str, optional
            title of the plot
        figFilename : str, optional
            output file name
        colormap : str, optional
            colormap used for the color bar
        set_center_to_zero : bool, optional
            If you are interested in the sign of transition energy (e.g. insulator-semimetal-topological insulator phase transition), set to True.
            Default is True

        Returns
        -------
        fig : matplotlib.figure.Figure object

        """
        if not self.__output_subfolders_exist():
            raise RuntimeError("Simulation output does not exist for this sweep!")

        # validate input
        self.__validate_sweep_variables(x_axis)
        self.__validate_sweep_variables(y_axis)

        self.__calc_HH1_HH2_energy_differences()

        # x- and y-axis coordinates and 2D array-like of overlap data
        x_values, y_values, transition_energies = self.__slice_data_for_colormap_2D('HH1-HH2', x_axis, y_axis, datatype=np.double)


        # instantiate 2D color plot
        fig, ax = plt.subplots()
        if not plot_title: plot_title = "Energy difference HH1 - HH2"
        self.__setup_2D_color_plot(ax, x_axis, y_axis, x_label, y_label, plot_title, x_values, y_values)

        # color setting
        if colormap is None:  
            # default colors
            if set_center_to_zero: 
                colormap = 'seismic'
            else:
                colormap = 'viridis'
        if set_center_to_zero:
            from matplotlib import colors
            divnorm = colors.TwoSlopeNorm(vcenter=0.)
            pcolor = ax.pcolormesh(x_values, y_values, transition_energies * CommonShortcuts.scale1ToMilli, cmap=colormap, norm=divnorm, shading='auto')
        else:
            pcolor = ax.pcolormesh(x_values, y_values, transition_energies * CommonShortcuts.scale1ToMilli, cmap=colormap, shading='auto')
        
        cbar = fig.colorbar(pcolor)
        cbar.set_label("Hole energy difference HH-LH ($\mathrm{meV}$)")
        fig.tight_layout()
        plt.show()

        if figFilename is None or figFilename == "":
            name = os.path.split(self.output_folder_path['original'])[1]
            figFilename = name + "_HH1_HH2_EnergyDifference"
        self.shortcuts.export_figs(figFilename, "png", output_folder_path=self.__get_output_folder_path(), fig=fig)

        return fig

    ### in-plane k ###########################################################
    def plot_inplaneK(self):

        inplane_k = self.shortcuts.getKPointsData1D_in_folder(self.data.loc[0, 'output_subfolder'])   # assuming k points are identical to all the sweeps
        return self.shortcuts.plot_inplaneK(inplane_k)


